// TODO: review
#include <bits/stdc++.h>
#define i64 long long
using namespace std;
const int N = 1e6 + 10;
i64 a[N];
i64 fl[N]; // 前缀子段和
i64 fr[N]; // 后缀子段和
int main()
{
	// 双子段和,前后缀和
	int n;
	cin >> n;
	for (size_t i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	fl[0] = a[0];
	// 前缀方向
	for (size_t i = 1; i < n; i++)
	{
		fl[i] = max(fl[i - 1] + a[i], a[i]); // 相加or 开新子段
	}
	for (size_t i = 1; i < n; i++)
	{
		fl[i] = max(fl[i - 1], fl[i]); // 前后滚动取大
	}
	fr[n - 1] = a[n - 1];
	// 后缀方向
	for (size_t i = n - 2; i > 0; i--)
	{
		fr[i] = max(fr[i + 1] + a[i], a[i]); // 相加or 开新子段
	}
	for (size_t i = n - 2; i > 0; i--)
	{
		fr[i] = max(fr[i + 1], fr[i]); // 前后滚动取小
	}
	/*
	!! Comment is generated by DeepSeek V3.1
	NOTE: 对fleft和fright的理解：
	- fleft[i]：0~i 范围内的最大子段和（全局最大，子段不一定在i结尾）；
	- fright[i]：i~n-1 范围内的最大子段和（全局最大，子段不一定在i开头）。

	算法核心：枚举"中间间隔位置k"（即两个子段中间至少间隔k这个元素），
	此时左侧子段只能在 0~k-1 范围内，右侧子段只能在 k+1~n-1 范围内。
	因此，对每个k（1<=k<=n-2，0-based），计算 fleft[k-1] + fright[k+1]，
	所有可能的和中最大的即为答案。
	*/
	i64 ans = fl[0] + fr[2];
	for (size_t i = 1; i < n - 1; i++)
	{
		ans = max(ans, fr[i + 1] + fl[i - 1]);
	}

	cout << ans << '\n';

	return 0;
}